// src/pages/minifigs-by-theme.tsx
import Head from "next/head";
import Link from "next/link";
import { useEffect, useMemo, useState } from "react";
import MinifigCard, { MinifigItem } from "@/components/MinifigCard";
import MinifigStats from "@/components/MinifigStats";

type ApiResp = {
  items: MinifigItem[];
  meta: { total: number; page: number; pageSize: number };
};

type Facet = { theme: string; count: number };
type ThemesResp = { facets: Facet[]; meta: { total: number } };

export default function MinifigsByThemePage() {
  const [items, setItems] = useState<MinifigItem[]>([]);
  const [page, setPage] = useState(1);
  const [limit, setLimit] = useState(36);
  const [loading, setLoading] = useState(false);
  const [total, setTotal] = useState(0);

  const [themes, setThemes] = useState<Facet[]>([]);
  const [theme, setTheme] = useState<string>("");

  const pageCount = useMemo(() => Math.max(1, Math.ceil(total / limit)), [total, limit]);

  useEffect(() => {
    let alive = true;
    fetch(`/api/themes?type=MINIFIG`)
      .then((r) => r.json())
      .then((data: ThemesResp) => {
        if (!alive) return;
        const arr = Array.isArray(data?.facets) ? data.facets : [];
        setThemes(arr);
      })
      .catch(() => {});
    return () => {
      alive = false;
    };
  }, []);

  useEffect(() => {
    let alive = true;
    setLoading(true);
    const params = new URLSearchParams({
      page: String(page),
      limit: String(limit),
      ...(theme ? { theme } : {}),
    });
    // Use the basic endpoint; it accepts theme (server-side will filter if implemented)
    fetch(`/api/minifigs-basic?${params.toString()}`)
      .then((r) => r.json())
      .then((data: ApiResp) => {
        if (!alive) return;
        setItems(Array.isArray(data?.items) ? data.items : []);
        setTotal(Number(data?.meta?.total || 0));
      })
      .catch(() => {
        if (alive) {
          setItems([]);
          setTotal(0);
        }
      })
      .finally(() => alive && setLoading(false));
    return () => {
      alive = false;
    };
  }, [page, limit, theme]);

  return (
    <>
      <Head>
        <title>Minifigures by Theme — 1 Brick at a Time</title>
      </Head>

      <main className="wrap">
        <header className="header">
          <div className="left">
            <h1>Minifigures</h1>
            <MinifigStats />
            <p className="muted">
              {theme ? `${theme}` : "All themes"} • page {page} of{" "}
              {Math.max(1, Math.ceil(total / limit))} • {total.toLocaleString()} lots
            </p>
          </div>
          <nav className="tabs">
            <Link className="tab" href="/minifigs">Minifigures</Link>
            <Link className="tab active" href="/minifigs-by-theme">By Theme</Link>
          </nav>
        </header>

        <section className="filters">
          <label>
            Theme
            <select value={theme} onChange={(e) => { setPage(1); setTheme(e.target.value); }}>
              <option value="">All</option>
              {themes.map((t) => (
                <option key={t.theme} value={t.theme}>
                  {t.theme} ({t.count})
                </option>
              ))}
            </select>
          </label>
          <label>
            Per page
            <select value={limit} onChange={(e) => { setPage(1); setLimit(Number(e.target.value)); }}>
              <option value={24}>24</option>
              <option value={36}>36</option>
              <option value={48}>48</option>
              <option value={72}>72</option>
            </select>
          </label>
        </section>

        {loading ? (
          <p>Loading…</p>
        ) : items.length === 0 ? (
          <p>No items found.</p>
        ) : (
          <section className="grid">
            {items.map((it) => (
              <MinifigCard key={`${it.id}-${it.itemNo}`} item={it} />
            ))}
          </section>
        )}

        <footer className="pager">
          <button onClick={() => setPage((p) => Math.max(1, p - 1))} disabled={page <= 1}>
            ‹ Prev
          </button>
          <span>
            Page {page} / {pageCount}
          </span>
          <button onClick={() => setPage((p) => Math.min(pageCount, p + 1))} disabled={page >= pageCount}>
            Next ›
          </button>
        </footer>
      </main>

      <style jsx>{`
        .wrap { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { display: flex; justify-content: space-between; align-items: flex-end; gap: 12px; margin-bottom: 16px; }
        .tabs { display: flex; gap: 8px; }
        .tab { display: inline-flex; align-items: center; height: 36px; padding: 0 12px; border-radius: 8px; border: 1px solid #ddd; background: #fafafa; text-decoration: none; }
        .tab.active { border-color: #caa21a; background: #fdf3bf; }
        .muted { color: #666; font-size: 13px; margin: 2px 0; }
        .filters { display: flex; gap: 12px; align-items: center; margin: 10px 0 18px; }
        .filters label { display: grid; gap: 4px; font-size: 12px; color: #444; }
        .filters select { height: 34px; border-radius: 8px; border: 1px solid #ccc; background: #fff; padding: 0 10px; min-width: 180px; }
        .grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 14px; }
        @media (max-width: 1100px) { .grid { grid-template-columns: repeat(3, 1fr); } }
        @media (max-width: 800px) { .grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 520px) { .grid { grid-template-columns: 1fr; } }
        .pager { display: flex; align-items: center; gap: 10px; margin: 18px 0; }
        .pager button { height: 34px; border-radius: 8px; border: 1px solid #ccc; background: #fff; padding: 0 10px; }
      `}</style>
    </>
  );
}